## 浏览器

:::tip

**最后更新时间：2018年09月11日**

**字数：**

:::

**努力不一定成功，但放弃一定失败！加油**

## 学习资料

* [浏览器](https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8/213911?fr=aladdin)
* [Chrome内存分析工具](https://blog.csdn.net/bug_zero/article/details/54883083)
* [JavaScript垃圾回收机制](https://www.cnblogs.com/dolphinX/p/3348468.html)

## 内存泄漏

* 内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果

* 指计算机可用内存的逐渐减少，当程序持续无法释放其使用的临时内存时就会发生。
* JavaScript的web应用也会经常遇到在原生应用程序中出现的内存相关的问题，如泄漏和溢出，web应用也需要应对垃圾回收停顿

* 尽管JavaScript使用垃圾回收进行自动内存管理，但有效的(effective)内存管理依然很重要。

## JavaScript垃圾回收（GC）

* 和C#、Java一样JavaScript有自动垃圾回收机制，也就是说执行环境会负责管理代码执行过程中使用的内存，在开发过程中就无需考虑内存分配及无用内存的回收问题了
* JavaScript垃圾回收的机制：**找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。**

### 变量生命周期

* 不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。
* 一旦函数结束，局部变量就没有存在必要了，可以释放它们占用的内存。
* 但是这样的情况往往很复杂，必须闭包，貌似函数结束了，其实没有，这种情况下就需要分析了

### 标记清除（mark and sweep)

* 当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。
* 原则上讲不能够释放进入环境的变量所占的内存，它们随时可能会被调用的到。
* 垃圾回收器会在运行的时候给存储在内存中的`所有变量`加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包）
* 在这些完成之后`仍存在标记的就是要删除的变量`了，因为环境中的变量已经无法访问到这些变量了，然后垃圾回收器相会这些带有标记的变量机器所占空间。

### 引用计数(reference counting)

:::tip

**小峰哥初入编程，学习ios的时候，就是学的他们的引用计数，MRC和ARC，怀念**

:::

* 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。
* 引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1
* 如果该变量的值变成了另外一个，则这个值得引用次数减1
* 当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。

#### 引用计数缺点

* 可能会造成循环引用的问题，比如：对象A有一个属性指向对象B，而对象B也有有一个属性指向对象A，这样相互引用，就会造成内存泄露

### JavaScript垃圾回收触发

* 垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨
* 后期很多浏览器触发都是**动态触发**的
* 但是垃圾回收有时候是很不及时的，很多情况下效率也是很低的。

## Chrome开发工具内存分析

:::tip

**由于Chrome版本不同，会造成教程中有些不可用的问题，请大家谅解。**

**调试工具截图如下：选择Memory即可**

:::

<img src="http://bmob-cdn-4908.b0.upaiyun.com/2018/10/11/4cbc9d124014163e80420a3239ac80f5.png" />

### 基本术语和基本概念

* 介绍在内存分析时使用的常用术语，这些术语在为其它语言做内存分析的工具中也适用

### 对象大小(Object sizes)

* 把内存想象成一个包含基本类型(像数字和字符串)和对象(关联数组)的图表。它可能看起来像下面这幅一系列相关联的点组成的图。

<img src="http://bmob-cdn-4908.b0.upaiyun.com/2018/10/13/7cf701d6406e0e7080cb1a58d2106b9d.png" />

### 对象使用内存

* 一个对象有两种使用内存的方法：
  - 对象自身直接使用
  - 隐含的保持对其它对象的引用，这种方式会阻止垃圾回收(简称GC)对那些对象的自动回收处理。

* 相关调试工具中的显示：**直接占用内存(Shallow Size)**和**占用总内存(Retained Size)**，如图：

<img src="http://bmob-cdn-4908.b0.upaiyun.com/2018/10/13/05d8ea614065399e80247703d1198ba0.png" />

### 直接占用内存(Shallow Size)

* 这个是对象本身占用的内存，不包括引用的对象占用的内存
* 典型的JavaScript对象都会有保留内存用来描述这个对象和存储它的直接值。
* 一般只有**数组**和**字符串**会有明显的直接占用内存(Shallow Size)。
* 但字符串和数组常常会在渲染器内存中存储主要数据部分，仅仅在JavaScript对象栈中暴露一个很小的包装对象。

* 渲染器内存
  * 指你分析的页面在渲染的过程中所用到的所有内存
  * 页面本身的内存 + 页面中的JS堆用到的内存 + 页面触发的相关工作进程(workers)中的JS堆用到的内存。
  * **然而，通过阻止垃圾自动回收别的对象，一个小对象都有可能间接占用大量的内存**。

### 占用总内存(Retained Size)

* 占用总内存包括引用的对象所占用的内存
* 一个对象一但删除后，它引用的依赖对象就不能被**GC根(GC root)**引用到，它们所占用的内存就会被释放，一个对象占用总内存包括这些依赖对象所占用的内存。

### 内存图

* 内存图由一个根部开始，可能是浏览器的window对象或Node.js模块Global对象。
* 这些对象如何被内存回收不受用户的控制。

<img src="http://bmob-cdn-4908.b0.upaiyun.com/2018/10/13/b98313e340afe249807127f7b1a3d893.png" />

:::tip

**不能被GC根遍历到的对象都将被内存回收。**

**直接占用内存和占用总内存字段中的数据是用字节表示的**

:::

### 对象的占用总内存树

* 堆是由各种互相关联的对象组成的网状结构。
* 在数字领域，这种结构被称为**图**或**内存图**。
* 图是由**边缘(edges)**连接着的**节点(nodes)**组成的，他们都被贴了标签。

#### 边缘(edges)

* 标签名就是属性名

#### 节点(nodes)

* 节点的标签名是由创建他们的**构造(constructor)函数**的名称确定

#### 距离(distance)

* 是指对象到GC根的距离。
* 如果同一个类型的所有对象的距离都一样，而有一小部分的距离却比较大，那么就可能出了些你需要进行调查的问题了。

### 支配对象(Dominators)

* 支配对象就像一个树结构，因为每个对象都有一个支配者。
* 一个对象的支配者可能不会直接引用它支配的对象，就是说，支配对象树结构不是图中的生成树。

### 拍一个快照

### 清除快照

### 切换快照视图

* 一个快照可以根据不同的任务切换视图。
* 下面是三个默认视图：
  * Summary(概要) - 通过构造函数名分类显示对象；
  * Comparison(对照) - 显示两个快照间对象的差异；
  * Containment(控制) - 可用来探测堆内容；
  * statistics：图表统计